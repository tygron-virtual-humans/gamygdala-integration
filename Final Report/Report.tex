\documentclass[11pt]{article}
\usepackage{a4}
\usepackage[utf8]{inputenc}
\usepackage{glossaries}
\usepackage{hyperref}
\usepackage[T1]{fontenc}

\usepackage[toc,page]{appendix}

\makeglossaries

\newglossaryentry{Gamygdala}
{
	name=Gamygdala,
	description={An emotional engine created to simulate emotions for virtual identities\cite{Gamygdala}.}
}

\newglossaryentry{GOAL}
{
	name=GOAL,
	description={A programming language developed at TU Delft for creating Virtual Humans\cite{GOAL}.}
}

\newglossaryentry{agent}
{
	name=agent,
	description={A virtual identity that uses logical rules to derive the wanted actions and can percept events from the environment. It is AI.}
}

\newglossaryentry{MoSCoW}
{
	name=MoSCoW,
	description={A method used to fill in requirements for a project based on difference in priority regarding the final goal of the project.\cite{MoSCoW}}
}


\title{Final Report}
\author{GROUP: Gamygdala-Integration:\\
	B.L.L. Kreynen, bkreynen, 4331842\\
	M. Spanoghe, mspanoghe, 4331834\\
	R.A.N. Starre, rstarre, 4334620\\
	Y.L. Verhoog, ylverhoog, 4155335\\
	J.H. Wooning, jwooning, 4245318\\
}

\begin{document}
% Title Page
\maketitle
\pagebreak
\tableofcontents
\pagebreak
\section{Abstract}

\clearpage

\section{Introduction}
In this section you can find a brief introduction to the context problem and to the solutions applied by group 3. 
\subsection{Problem description}
The research problem is stated by a company called Tygron. They provide local authorities with a game in which their city is fully simulated. In this game the council members can discuss difficult matters on where to build certain structures. By doing so they gain an understanding of everybody's needs and responsibilities. The main question that rises is the possibility of replacing one of those players with an Artificial Intelligence solution. Since the players of this game mostly interact in an emotional way, as real humans do, these bots should feel emotions too.\par 
This topic is very interesting because it has many applications. Both further research and different industries can profit from this. For this context project the students work in a large group that is subdivided into different smaller groups each with specific tasks. In total there are 4 groups of 5 students that work together. Together the whole group will make a proof of concept by creating a game in the Tygron engine\cite{Tygron}, creating an interface between the Tygron engine and \gls{GOAL} and creating both a plug-in and an integration of the \gls{Gamygdala} emotional engine in GOAL. The specific task of this subgroup is to provide the group that will create an agent with an integration of Gamygdala in GOAL. It is not our task to implement the engine itself, since it is already present, but it is our job to integrate it in GOAL in a way that programmers, like the other groups, can make use of this when creating virtual humans.\par 
In this report there is given a overview of the user requirements first. Then a list of the implemented software product is explained in detail. After that, you can find a reflection of the product and process from a software engineering perspective. This is followed by a detailed list of implemented features. A section on the Human Computer Interaction will then explain how the product and users interact. Finally a conclusion and outlook will list all the important findings and future improvements.
\\

\subsection{User requirements}
The user requirements are fully listed in the product planning. Here a brief overview is introduced.\par
The main goal of the project is giving a programmer in GOAL the ability to provide the agents he is creating with emotions. This means that the agents have to express emotions, but can also act based on these emotions. Without a lot of work (it should be very easy) the programmer can define what makes the agent happy and what not. This can be done by setting a configuration file which is provided with a full documentation. Also he can check which emotions are present at a certain moment for a certain agent. This so that he can debug with the emotions and see what results certain settings can cause. Furthermore the programmer can query the emotions in GOAL so that he can program certain logical rules. For example, the programmer queries whether the agent is happy. If he is happy, then he should stop moving and chill out.\par Keep in mind that all the features and settings need to be documented very thoroughly so that programmers can add these emotional features very easily. The focus is on all this being easy. No complicated settings are needed at all (they can be used when demanded) to get emotional agents. All these features are an overview of the requirements this project should fulfill at the end. As mentioned before, a full list of the user requirements in the MoSCoW-form can be found in the product planning.

\clearpage

\section{Overview of the developed and implemented software product}
This section gives an overview of what we implemented in this project. 

\subsection{Emotion configuration}
The emotion configuration is the most important part of our implementation. It is an instance which holds all the gamygdala settings for a GOAL program. This EmotionConfig instance is used in the main GOAL cycle to determine if the emotions of the gamygdala agent should be updated.

\subsection{Parser}
To be able to use the EmotionConfig in GOAL we had to write a parser for the EmotionConfig. The parsing for the goal and mas2g files in GOAL is done by using the parsing tool ANTLR. However, after we made up a syntax for the emotion configuration we thought it would be overly complicated to use ANTLR for this parser.\\
Instead we used a simple implementation where the parser iterates over the lines and reads what setting is configured on that line. While parsing the EmotionConfig instance is updated according to the configured settings. For the goals, subgoals and relations a new object is created to store in the EmotionConfig. 

\subsection{Mentalstate}
We had to implement changes to the mentalstate to be able to create a emotionbase for an agent. With this emotionbase the programmer using goal can easily see what emotions an agent currently has. Before prolog starts reasoning about beliefs it merges all beliefbases for an agent, with the emotionbase (which is a beliefbase) prolog also takes the emotions into account. This way the programmer can use the emotions just as he would use any other belief.

\subsection{SimpleIDE}
We also changed the simpleIDE to make it able to edit the emotion configuration file. This includes changes in the filepanel to let the emo2g files show as a child of the mas2g file, parsing errors and a tab to be able to debug the emotion base. We unfortunately did not have the time to add syntax highlighting for the emotion configuration file or the emotionFile block in the mas2g file. 

\clearpage

\section{Reflection on the product and process from a software engineering perspective}
In this section we will reflect in on our product and our process from a software engineering perspective. We will describe some of the problems we encountered and what we learned from them as well as how things could have been improved. We will start with a look at the product and after that we will look at the process.

\subsection{Product}
We started off with an existing code base (GOAL) on which we had to build. Since the goal was to make working with emotions in the GOAL environment intuitive and similar to working with the existing GOAL language we tried to keep true to the existing architecture. There were four main repositories in which we had to make changes, we will start with the Grammar repository.
The Grammar repository is where we had to add code to give goal programmers the option to use emotions without knowing what exactly is happening while also giving options for programmers to tinker with the emotion settings that are available in the Gamygdala engine. To facilitate this we made a file with configurations. Since we found that it was difficult to use without any knowledge about the Gamydgala engine we made a document to help configuring this file.\par 
In the Runtime repository the emotions had to be handled during runtime. This was done by connecting the adding and dropping of goals to the Gamygdala engine and by making sure that the emotion updates from the Gamydala engine were handled and added to a base similar to how percepts are updated every cycle. We implemented this by adding calls in the existing code to functions that we made to handle the emotions. For the structure of our functions we looked at how the existing code handled similar situations. After some initial time to get to know the existing code base we were able to implement the functionality we wanted in this repository relatively easily. However, when we tried to add to add an EmotionBase rather than use the PerceptBase to process the emotion we learned that this was a lot harder to do. \par 
In the simpleIDE we wanted to be able to show the emotion from the EmotionBase similar to how percepts, messages, and beliefs are shown in their own tab. While we were able to do this the problem was not to make emotions visible in the EmotionBase but rather to get these changes functional in prolog and goal files. Which brings us to the changes in the Mentalstate repository.
To create an EmotionBase we had to make changes to the Mentalstate repository. Since the functionality of the EmotionBase was going to be very similar to that of the PerceptBase the code that we added in this repository was very similar to the already existing code. This repository is also where we had to make sure that the emotion information was inserted into the prolog knowledge base, and while this seemed to be simple enough this is where we ran into troubles with the EmotionBase. \par 
The difficulties with the addition of the EmotionBase mostly seemed to stem from issues with the dependencies between the repositories, and since the existing code base was pretty large this made it difficult to comprehend why it was not working as we intended. This showed that when writing software it is critical to maintain good testing coverage and integration testing, which the existing code lacked. We also learned that when you want to implement new functionality into an existing code base with some hurry, it is best to focus solely on functionality rather than trying to implement it in a “nice” way. Especially if you aren’t sure the code will still work with the “nicer” implementation.

\subsection{Process}
We made use of an incremental and iterative software development process. Every week we made a scrum plan and at the end of the week we reflected on this plan and made a new one. Initially the tasks we made were not very fitting for scrum, they were somewhat too generic and did not lead to something we could demo. We were able to use the feedback given by the TA and the problems we encountered in our weekly scrums to improve our scrum process over the course of the project. \par 
We used git on the social platform Github in combination with TravisCI and Maven for our code versioning and continuous integration. The code bases we used were already on github and after cloning them to our own repositories we later had some troubles with the POM-files which were still referring to the original repositories. This problem came back several times, and we should probably have fixed this initially so any new issues would have been smaller and therefor easier to solve. \par 
Another problem we encountered here was that the original code already failed when doing integration tests, this had to do with the tests trying to open windows which was not possible and to solve this we had to ignore a few tests. Regarding testing, the original code lacked good test coverage and integration testing. Due to the difficulty of integration testing the whole code base including our new code we decided to focus our testing efforts on making unit tests involving the code we added to the existing code. However, the lack of integration tests available often make it hard to find where errors originated.  \par 
The original code also had a ton of Checkstyle errors and a lot of errors from the Maven Javadoc tool. We did not use Checkstyle because the errors were legion and if we used the Maven Javadoc tool the code would not compile. \par
This was also the first project where we made use of a pull-based development model. Initially we made some mistakes by pulling changes in the master onto our own base instead of rebasing. We also learned to squash a lot of small changes into fewer more substantial commits to make it easier to track the changes that were made. 
\clearpage

\section{Interaction Design}
This section will describe how we tried to validate the interaction of our users with our product. First there will be a description of the method used to gain feedback then the results from this will be discussed after which there will be an explanation of how we processed this feedback. Finally there will be a short discussion on what could be done to gain more valuable feedback.

\subsection{Used Method}
The idea used to gain the feedback from users on our product was to ask  the other group that is programming the virtual human in GOAL to complete a tutorial. This is a perfect group to do this with since they will have to work with our program to complete their own, they have experience with GOAL and know a little bit about gamygdala so they're a perfect example of our typical end user. They were asked to think out loud so that it was possible to identify any issues they were having. The recording of this session is attached to this report.

Sadly enough only three people of the other group were available, they worked on the tutorial in one team. This felt like the best set up because that way they talk with each other about what they're doing.

\subsection{Results}
From the feedback gained it became obvious that some of our documentation was not yet clear enough. There were three identifiable issues with the documentation:

\begin{itemize}
	\item  Sometimes small details about how something worked were plain missing.
	\item Sometimes information was not put in a central place. The users were for example not finding some details of how to use the emotion configuration, what they were looking for was mentioned somewhere in the documentation but due to it not being in one central place it was difficult to find.
	
	\item Some things were still plain wrong since they had been changed after the documentation was made.
\end{itemize}

Furthermore we identified one bug in the program when the users were working on the tutorial. 
\subsection{Reaction}
The details that were still missing in the documentation will be added to it and there will be updates to make sure that there are central parts of the documentation to find all relevant information about certain aspects of the program without having to go look at other parts of the documentation. We will also make sure that the wrong documentation is updated to be compliant with the current version of our program. The bug that was identified has since been fixed.

\subsection{Commentary}
The feedback we've gained is somewhat superficial, it was certainly useful feedback but sadly enough the other teams did not have enough time to use the program for an extended period of time and then have an interview with us. Pretty much all of the received feedback was feedback on the documentation, we feel like if they would have had more time to use our program that we would have received more valuable feedback on missing features and the usability of our implemented features.

Only being able to do it with one group also makes the feedback more limited the product should be tested on some more groups to gain more diverse feedback.

\clearpage


\section{Functionality Description}
\subsection{Default functionality}
The purpose of the integration of Gamygdala into the GOAL runtime is to provide all of Gamygdalas functionality continuously in the GOAL multi-agent system. This is possible because Gamygdala is, as GOAL obviously is, goal-oriented. This implementation was chosen so that developers do not need to code for every call to Gamygdala, but rather every update relevant to an agent's (specified) goals is evaluated by Gamygdala automatically. After evaluation, an agents updated emotional state is inserted into the emotion base, which can be queried by GOAL and is displayed in the GUI of the SimpleIDE GOAL development environment, similar to the belief and especially the percept base. Developers can use a large portion of the functionality of Gamygdala without having to write one line of extra code. It's just there doing its job. A developer can write agents that reason about their emotions just as if they were another percept from an environment, but in this isntance the environment is internal to the agent. Agents cannot read each others emotional states, only their own. They all have perfect poker faces. Developers can, of course, choose to let their agent notify other agents of their emotional state whenever they want through GOALs messaging system. This would be useful to do in many environments where agents should act human-like. People can choose to let each other know how they feel. Adding the option to do this automatically, with various levels of frequency and detail, could be a useful extension to this project if it is continued.

There are default values for all the parameters available to Gamygdala and many other options relevant to the function of Gamygdala within GOAL, which can be modified by developers in the emotion configuration file.


\subsection{Emotion configuration options}
In this section an overview is given of the options in the emotion configuration file. A selection of these options will be examined more closely.For more detailed descriptions of every option and their grammar, please refer to the EmotionConfig Documentation in Appendix ???. 

The emotion configuration file is optional. If it is not present in the same folder as the agent file, only default values will be used. If any options are not specified in the emotion configuration file, default values will be used.

It contains settings for the default parameters given to gamygdala, such as default goal utility, default goal congruence and the speed of decay of emotions and a whitelist option There are sections for the definition of goals and their individual utility which overrides the default,the the definitions of subgoals, which include the unique congruence of the subgoal, and the relations between agents.

\subsubsection{Gamygdala parameters}
Default Goal Utility\\
This value specifies how valuable achievement of a goal is for an agent. A positive value means achieving the goal is valuable and will cause positive emotions, a negative value implies achieving it will cause negative emotions. Normal setting is 1.\\
\\
Default achieved congruence\\
This value controls the congruence of the event that an agent achieves a goal. In simple environments it is usually set to 1, so achieving a goal simply registers as a positive event in Gamygdala, but for more complex MASs it might prove necessary to lower the congruence setting for subgoals that contribute to a larger goal relative to their importance.\\
\\
Default dropped congruence\\
The congruence of the event that a goal is dropped. Very similar to the achieved congruence, but with a different trigger. By default set to -1, so an agent will receive negative emotions from Gamygdala when a goal is dropped.\\
\\
Default belief likelihood\\
This is set to 0 or 1 in most cases because in GOAL beliefs are true or not, for example when a goal is achieved or dropped, and there is no probability. Gamygdala can do calculations on beliefs with probabilities and requires a likelihood parameter with every update. This setting can be overridden for subgoals of which it is not certain whether they contribute to a larger goal.\\
\\
\subsubsection{Goal definitions}
Goal types\\
There are two types of goals that can be specified in this section of the configuration. Common goals that are shared by all agents with that goal, and individual goals that are only pursued by a singular agent. If a goal is common, reaching it will cause the emotional states of all agents with that goal to be evaluated. If it is individual, only one agent will update and the rest will remain unaffected. For every goal, a utility can be specified that overrides the default setting. Individual goals can be specified without an agent name parameter so the individual goal is given to all agents. Goals should be named the same as they are in GOAL.\\
\\
Subgoal definition\\
In this section of the config file the congruence of goals towards other goals can be specified, creating a tree-like structure of goals that contribute toward each other. The likelihood that the achievement of a subgoal will contribute toward the larger goal can also be changed.
\subsubsection{Relation definition}
Here the relations between agents in a MAS can be specified. A positive number equals a good relationship, zero is indifference and a negative number means animosity. When an agents emotional state is updated, all agents it has a relation with update their emotional state proportional to the change and the strength and sign of the relationship. The names of agents given must be the same as their names in GOAL.


\section{Outlook}
This section gives a recommendation as to what possible improvements there still are for future expansion of the project.

\subsection{Emotion configuration parser}
First off we define the properties of the emotion configuration in a regular text file that is parsed by a simple parser. It's not a bad idea to improve upon this and to create a new file with the ANTLR framework that is used for the other files in GOAL as well. Furthermore while our parser does throw errors which mention which line numbers are still incorrect it would be nice if this could be statically checked and displayed in the SimpleIDE or the GOAL plug-in for eclipse.

\subsection{Emotion configuration}
Secondly there are still a few things that could be added to the emotion configuration. It is possible to define common goals and individual goals and it is possible to define that the individual goals only apply to certain agents. However it is not possible to define a notion of teams for the common goals, if a common goal is defined and two agents adopt this goal then it is assumed that they are working together on this goal in some instances it might be useful to have an optional parameter that allows you to define multiple teams for these common goals. However before adding something like this it should also be considered whether this does not complicate the emotion configuration too much for a feature that might not be all that widely used.

\subsection{Aspects of GOAL that influence emotions}
There are still some aspects in GOAL that are not being taken into account for the evaluation of emotions but which could potentially be interesting. For example bots can send messages to each other and bots can also try to reason about the goals and beliefs that other agents are holding. These parts of GOAL have no effect on emotions in the current implementation. An example of how this could affect emotions is that needing to drop a GOAL because of a message given by another agents is less bad than having to drop a GOAL because of your own observations (the idea being that you were notified beforehand and had to waste less time trying to achieve this goal before realizing you couldn't complete it anymore). While we're not sure how this should affect emotions exactly it would be interesting to take a look at what could be done in these areas. Although, again, adding definitions for these things might make the emotion configuration overly complicated for a feature that might not have that big of an effect, this should be considered when thinking of these features. Either a smart way of setting a standard for these messages (so that programmers just have to send the correct message and not worry about any other configuration) or a very easy way of defining them in the emotion configuration should be figured out.

\subsection{Causal agents}
At the moment determining the causal agent of dropping or achieving a goal is fairly simplistic, for individual goals the causal agent is always the agent itself and for common goals it is the agents that first achieved that goal. This does not always reflect the real world and it might be interesting to see what can be done to improve this. Again just like with the other sections it should be carefully thought out so that it does not complicate the use of gamygdala within GOAL too much. For this an potentially interesting solution would be to define a new drop and insert predicate that not only takes the goal/belief to drop/insert as input but that also allows the programmer to enter which agent caused this drop/insert.

\subsection{Code quality}
Finally, in terms of code quality there can always be improvements of course. Some parts of the code would benefit from being re-factored a bit. Most of the code would also benefit from better integration testing, but this is not only a problem in our own code but also in the code of GOAL. In terms of unit testing the code written by our group scores pretty high but throughout the project we noticed a few times that some changes created serious issue in GOAL but none of our tests notified us of this. This was caused by a shortage of integration testing, all the individual components still seemed to work perfectly fine but when combined in certain scenarios they failed and these scenarios were not always tested. As mentioned, this would also be a recommendation to GOAL itself, at one time for example a modification to updating the goal base caused one of our two agents to not perform any actions anymore at all, this was not caught by integration nor unit tests of GOAL.

\clearpage
\printglossaries

\begin{appendices}
	\section{HCI}
	In this appendix you can find a full report on the HCI meeting and all things that happened. Also with this appendix an audio file with a length of 1h16min is included which is a full recording of the tutorial. Here are the notes our group took during the introduction of our implementations.\\
	\\
	"From the start it seems that importing the project is an uncertain problem. For 2 of the 3 members of the group is it not clear what to do with it. One knows what to do and is helping. Cloning from Github directly into Eclipse seems to do weird things. Somehow the project is imported in that way but the folders are not known as source folders thus running Java code is not working. Now they are trying to clone to the harddisk and then import it into Eclipse. This seems to work. Now they mention that converting it to a maven project is not an option when you right click. It is under the tab configuration which is not mentioned clearly in the guide it seems. Now they tell the same thing for maven install. It is under the tab Run As which is somehow unclear for the members of the group. One of them is still in the goal perspective and this is bugging Eclipse. Bernd is helping them now and telling they should better be in the Java perspective instead of the GOAL perspective.\par 
	They have come to the point of running an agent with an empty emotionConfig configuration file. They are running the agent and they look at the current feelings of the agent and say that nothing is present. No emotions are given. They take a look at the mas2g file but it seems to be set correctly. They think it is a bug. It is a bug indeed. We tell them that we will fix this because it should give emotions when an empty file is set. Now they are trying out the whitelist option our group implemented. The information is not that clear. They are arguing what the intention is and what it does. They are not reading the documentation very thoroughly. They have gotten it working and now they ask us how you can make actions alter emotions. They can do this by adding goals to do the actions and then when the action is performed a goal is achieved and an emotion can be given. They are happy with this answer and think it is a good solution. They wonder why emotions like distress are coming. They did not read through all the documentation saying that dropping goals also cast emotions. They are getting a version working and they are excited that their agents get emotions. They wonder now what the isIncremental does. They can find this in the Gamygdala paper but it is a bit unclear that the last parameter(boolean) is about this setting. We will change this. \par Now they have a version working with subgoals. They tried to run with a goal with a congruence of 3. This cannot happen since the congruence must be between -1 and 1. It is mentioned at a certain section but not in the section of the subgoals. Now they have finished the single bot tasks and will see if they can get two bots working together.\par It seems unclear they have to change the masfile to run the second agent with the same GOAL code. After a while our group helped them because this is just a little change in the commands in the mas2g files. Now they want to query an emotion and alter an action. They try to use the gam() predicate but it is not correct. They should use the emo() predicate. This is being mentioned incorrectly in the tutorial. They tell us they will try to let one agent chill out in the Dropzone when he is happy enough. They get this working after a while because first they let him perform an action but the logical rule was not high enough in the calling order so other logical rules are getting called before that one. This is something you should think about when programming in GOAL. They set the relations which works the first time they try it. They reflect on what the did and are done."\\
	\\
	Together with these notes the full audio file can be found here:
	reference
\end{appendices}





\begin{thebibliography}{9}
	
	\bibitem{GOAL}
	GOAL programming language
	\url{http://ii.tudelft.nl/trac/goal}
	
	\bibitem{Gamygdala}
	Gamygdala emotion engine
	\url{http://ii.tudelft.nl/~joostb/gamygdala/index.html}
	
	\bibitem{MoSCoW}
	MoScoW method
	\url{http://en.wikipedia.org/wiki/MoSCoW_method }
	
	\bibitem{Tygron}
	Tygron engine
	\url{http://www.tygron.com }
	
	\bibitem{SimpleIDE}
	Simple IDE
	\url{https://github.com/goalhub/simpleIDE }
	
	
\end{thebibliography}

\end{document}     
